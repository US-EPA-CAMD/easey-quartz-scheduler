using System;
using System.Collections.Generic;
using System.Data.SqlClient;    // for SQLServer support
using System.Security.Permissions;
using System.Data.SqlTypes;
using System.Data;
using System.Diagnostics;	    // for debug trace statements

using ECMPS.Common;
using ECMPS.Definitions.Extensions;


namespace ECMPS.Checks.DatabaseAccess
{
    /// <summary>
    /// Database abstration class for SQL Server
    /// </summary>
    public class cDatabase
    {

        #region Public Types

        /// <summary>
        /// The catalogs/databases we have available in ECMPS
        /// </summary>
        public enum eCatalog
        {
            /// <summary>
            /// The "DATA" catalog, i.e. ECMPS
            /// </summary>
            DATA = 0,

            /// <summary>
            /// the "AUX" catalog, i.e. ECMPS_AUX
            /// </summary>
            AUX = 1,

            /// <summary>
            /// The "workspace" catalog, i.e. ECMPS_WS
            /// </summary>
            WORKSPACE = 2,

            /// <summary>
            /// The catalog for CHET 
            /// </summary>
            CHET = 3,

            /// <summary>
            /// The SQL Server's "Master" database
            /// </summary>
            MASTER = 4
        }

        #endregion


        #region Public Properties and their associated member variables

        private SqlCommand m_sqlCmd = null;
        private SqlConnection m_sqlConn = null;

        private int m_nCmdTimeout = 60 * 15;     // 15 minutes
        private int m_nConnTimeout = 5;         // 5 seconds

        static private string _sDataConnString = null;
        static private string _sAuxConnString = null;
        static private string _sWorkspaceConnString = null;

        /// <summary>
        /// The default command timeout (15 minutes)
        /// </summary>
        public static int DefaultCommandTimeout
        {
            get { return 60 * 15; }
        }

        // Internal Error Variables

        /// <summary>
        /// Did we catch an error/exception or not
        /// </summary>
        private bool m_bInternalError = false;

        /// <summary>
        /// Last exception caught by this class
        /// </summary>
        private Exception _LastException = null;
        /// <summary>
        /// The last error generated by this class
        /// </summary>
        private string m_sLastError = "";

        static private bool _bStealth = false;

        /// <summary>
        /// Do we show errors, or are we being stealthy?
        /// </summary>
        public static bool StealthMode
        {
            get { return _bStealth; }
            set { _bStealth = value; }
        }

        /// <summary>
        /// The SqlClient.SqlCommand object
        /// </summary>
        public SqlCommand SQLCommand
        {
            get { return m_sqlCmd; }
        }

        /// <summary>
        /// The SqlClient.SqlConnection object
        /// </summary>
        public SqlConnection SQLConnection
        {
            get { return m_sqlConn; }
        }

        /// <summary>
        /// Indicates the state of the SqlConnection.
        /// </summary>
        public ConnectionState State
        {
            get
            {
                if (m_sqlConn == null)
                    return ConnectionState.Closed;
                return m_sqlConn.State;
            }
        }

        /// <summary>
        /// Connection string used to connect to ECMPS Data database
        /// </summary>
        static public string DataConnectionString
        {
            get { return _sDataConnString; }
            set { _sDataConnString = value; }
        }

        /// <summary>
        /// Connection string used to connect to ECMPS_Aux database
        /// </summary>
        static public string AuxConnectionString
        {
            get { return _sAuxConnString; }
            set { _sAuxConnString = value; }
        }

        /// <summary>
        /// Connection string used to connect to ECMPS_WS database
        /// </summary>
        static public string WorkspaceConnectionString
        {
            get { return _sWorkspaceConnString; }
            set { _sWorkspaceConnString = value; }
        }

        /// <summary>
        /// Was there an internal error? An internal error is trapping an exception!
        /// </summary>
        public bool InternalError
        {
            get { return m_bInternalError; }
        }

        /// <summary>
        /// Get the last error generated by this class
        /// </summary>
        public string LastError
        {
            get { return m_sLastError; }
        }

        /// <summary>
        /// The last exception caught, if any
        /// </summary>
        public Exception LastException
        {
            get { return _LastException; }
        }

        private string m_sModule = null;
        /// <summary>
        /// The module/application name to give the connection
        /// </summary>
        public string ModuleName
        {
            get { return m_sModule; }
            set { m_sModule = value; }
        }

        /// <summary>
        /// The timeout to assign to the command objects created.
        /// Default is 5 minutes
        /// </summary>
        public int CommandTimeout
        {
            get
            {
                int nRetVal = m_nCmdTimeout;
                if (m_sqlCmd != null)
                    nRetVal = m_sqlCmd.CommandTimeout;
                return nRetVal;
            }
            set
            {   // always the max of the value passed in and the default command timeout
                m_nCmdTimeout = value;
                if (m_sqlCmd != null)
                    m_sqlCmd.CommandTimeout = m_nCmdTimeout;
            }
        }

        /// <summary>
        /// The connection timeout to assign. Default is 15 seconds.
        /// Can only be set on new connection objects.
        /// </summary>
        public int ConnectionTimeout
        {
            get
            {
                int nRetVal = m_nConnTimeout;
                if (m_sqlConn != null)
                    nRetVal = m_sqlConn.ConnectionTimeout;
                return nRetVal;
            }
            set
            {
                m_nConnTimeout = value;
            }
        }

        #endregion


        #region Construstors, startup code and cleanup code

        /// <summary>
        /// Create a cDatabase object and get a connection to the specified catalog
        /// </summary>
        /// <param name="initCatalog">The name of the catalog to connect to</param>
        /// <param name="nCmdTimeout">The timeout to assign to the command objects created.</param>
        /// <param name="sModule">The calling module</param>
        /// <returns>A cDatabase object with the connection already opened</returns>
        public static cDatabase GetConnection(eCatalog initCatalog, int nCmdTimeout, string sModule)
        {
            cDatabase me = new cDatabase(sModule, nCmdTimeout);
            me.Open(initCatalog);

            return me;
        }

        /// <summary>
        /// Create a cDatabase object and get a connection to the specified catalog
        /// </summary>
        /// <param name="initCatalog">The name of the catalog to connect to</param>
        /// <param name="sModule">The calling module</param>
        /// <returns>A cDatabase object with the connection already opened</returns>
        public static cDatabase GetConnection(eCatalog initCatalog, string sModule)
        {
            cDatabase me = new cDatabase(sModule);
            me.Open(initCatalog);

            return me;
        }

        /// <summary>
        /// Create a cDatabase object and get a connection to the ECMPS "DATA" catalog
        /// </summary>
        /// <param name="sModule">The calling module</param>
        /// <returns>A cDatabase object with the connection already opened</returns>
        public static cDatabase GetConnection(string sModule)
        {
            return GetConnection(eCatalog.DATA, sModule);
        }

        /// <summary>
        /// Default constructor
        /// </summary>
        public cDatabase()
        {
        }

        /// <summary>
        /// Constructor with module name
        /// </summary>
        /// <param name="sModule">The module/application name to give the connection</param>
        public cDatabase(string sModule)
        {
            m_sModule = sModule;
        }

        /// <summary>
        /// Constructor with module name, connection strings, and command timeout
        /// </summary>
        /// <param name="sModule">The module/application name to give the connection</param>
        /// <param name="nCmdTimeout">The timeout to assign to the command objects created.</param>
        public cDatabase(string sModule, int nCmdTimeout)
        {
            m_sModule = sModule;
            m_nCmdTimeout = nCmdTimeout;
        }

        /// <summary>
        /// Clean up all internal variables/objects
        /// </summary>
        public virtual void Dispose()
        {
            try
            {
                if (m_sqlCmd != null)
                    m_sqlCmd.Dispose();
                if (m_sqlConn != null)
                {
                    if (m_sqlConn.State == ConnectionState.Open)
                        m_sqlConn.Close();
                    m_sqlConn.Dispose();
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.ToString());
            }
        }

        #endregion


        #region Public Methods: Database Access

        /// <summary>
        /// Get a connection to the ECMPS "DATA" database
        /// </summary>
        /// <returns>True if a connection was made to the ECMPS database, or false if error and LastError will contain error message</returns>
        public bool Open()
        {
            return Open(eCatalog.DATA);
        }

        /// <summary>
        /// Get a connection to the ECMPS database for the Initial Catalog in question
        /// </summary>
        /// <param name="initCatalog">The name of the database to connect to</param>
        /// <returns>An open connection to the ECMPS database, or null if error and LastError will contain error message</returns>
        public bool Open(eCatalog initCatalog)
        {
            bool bRetVal = false;

            // reset our error flag!
            m_bInternalError = false;

            if (m_sqlConn != null)
            {
                try
                {
                    if (m_sqlConn.State == ConnectionState.Open)
                        m_sqlConn.Close();
                }
                catch (Exception ex)
                {
                    // ignore this
                    Debug.WriteLine(ex.ToString());
                }
                finally
                {
                    m_sqlConn.Dispose();
                    m_sqlConn = null;
                }
            }

            string sConnString = _sDataConnString;
            if (initCatalog == eCatalog.AUX)
                sConnString = _sAuxConnString;
            else if (initCatalog == eCatalog.WORKSPACE)
                sConnString = _sWorkspaceConnString;
            m_sqlConn = new SqlConnection(sConnString);

            try
            {
                m_sqlConn.Open();
                if (initCatalog == eCatalog.MASTER || initCatalog == eCatalog.CHET)
                    ChangeDatabase(initCatalog);
                bRetVal = true;
            }
            catch (SqlException sqlEx)
            {
                string sError = string.Format("The action failed. Connection String: {0}", sConnString);

                _LastException = new Exception(sError, sqlEx);
                _LastException.Source = "ECMPS.Client.Common.cDatabase.Open()";
                m_sLastError = sqlEx.Message;

                m_sqlConn.Dispose();
                m_sqlConn = null;

                // set our error flag!
                m_bInternalError = true;

                if (_bStealth == false)
                    Logging.LogException(_LastException, "Error Connecting to Database");
            }

            return bRetVal;
        }

        /// <summary>
        /// Attempt to close the connection
        /// </summary>
        public void Close()
        {
            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            if (m_sqlConn == null)
                return;

            m_sqlConn.Close();
        }

        /// <summary>
        /// Begin a transaction on the connection
        /// </summary>
        /// <returns></returns>
        public SqlTransaction BeginTransaction()
        {
            return m_sqlConn.BeginTransaction();
        }

        /// <summary>
        /// Change the database the connection is currently attached to
        /// </summary>
        /// <param name="sDBName">The name of the database to change to</param>
        /// <returns>True if successful, false if an error occured.</returns>
        public bool ChangeDatabase(string sDBName)
        {
            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            if (m_sqlConn == null)
                return false;

            // reset our error flag!
            m_bInternalError = false;

            if (m_sqlConn.State == ConnectionState.Closed)
                m_sqlConn.Open();
            m_sqlConn.ChangeDatabase(sDBName);

            return true;
        }

        /// <summary>
        /// Change the database the connection is currently attached to
        /// </summary>
        /// <param name="initCatalog">The database to change to</param>
        /// <returns>True if successful, false if an error occured.</returns>
        public bool ChangeDatabase(eCatalog initCatalog)
        {
            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            if (m_sqlConn == null)
                return false;

            // reset our error flag!
            m_bInternalError = false;

            string sDBName = "";
            switch (initCatalog)
            {
                case eCatalog.AUX:
                    sDBName = "ECMPS_AUX";
                    break;

                case eCatalog.DATA:
                    sDBName = "ECMPS";
                    break;

                case eCatalog.WORKSPACE:
                    sDBName = "ECMPS_WS";
                    break;

                case eCatalog.CHET:
                    sDBName = "CHET";
                    break;

                case eCatalog.MASTER:
                    sDBName = "master";
                    break;
            }

            if (m_sqlConn.State == ConnectionState.Closed)
                m_sqlConn.Open();
            m_sqlConn.ChangeDatabase(sDBName);

            return true;
        }

        /// <summary>
        /// Returns a cloned table based on the database table or view 
        /// with the passed table name.
        /// </summary>
        /// <param name="tableName">Name of the table or view to clone.</param>
        /// <returns>The cloned table.</returns>
        public DataTable CloneDataTable(string tableName)
        {
            string sql = string.Format("select * from {0} where null is not null", tableName);

            DataTable result = GetDataTable(sql);

            return result;
        }

        /// <summary>
        /// Create an SQL command object to run a stored procedure
        /// </summary>
        /// <param name="sProcName">The stored procedure to be executed</param>
        /// <returns>True if successfull, False otherwise</returns>
        public bool CreateStoredProcedureCommand(string sProcName)
        {
            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            if (m_sqlConn == null)
                return false;

            // reset our error flag!
            m_bInternalError = false;

            if (m_sqlCmd != null)
            {
                try
                {
                    m_sqlCmd.Dispose();
                    m_sqlCmd = null;
                }
                catch (Exception)
                {
                }
            }

            m_sqlCmd = m_sqlConn.CreateCommand();
            m_sqlCmd.CommandText = sProcName;
            m_sqlCmd.CommandTimeout = m_nCmdTimeout;
            m_sqlCmd.CommandType = CommandType.StoredProcedure;

            return true;
        }

        /// <summary>
        /// Create an SQL command object to run a stored procedure
        /// </summary>
        /// <param name="sProcName">The stored procedure to be executed</param>
        /// <param name="sqlTrans">The SqlTransaction object to associate with this command</param>
        /// <returns>True if successfull, False otherwise</returns>
        public bool CreateStoredProcedureCommand(string sProcName, SqlTransaction sqlTrans)
        {
            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            if (m_sqlConn == null)
                return false;

            // reset our error flag!
            m_bInternalError = false;

            if (m_sqlCmd != null)
            {
                try
                {
                    m_sqlCmd.Dispose();
                    m_sqlCmd = null;
                }
                catch (Exception)
                {
                }
            }

            m_sqlCmd = m_sqlConn.CreateCommand();
            m_sqlCmd.CommandText = sProcName;
            m_sqlCmd.CommandTimeout = m_nCmdTimeout;
            m_sqlCmd.CommandType = CommandType.StoredProcedure;
            m_sqlCmd.Transaction = sqlTrans;

            return true;
        }

        /// <summary>
        /// Create an SQL command object to run the specified SQL query
        /// </summary>
        /// <param name="sSQL">The query to run</param>
        /// <returns>True if successfull, False otherwise</returns>
        public bool CreateTextCommand(string sSQL)
        {
            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            if (m_sqlConn == null)
                return false;

            // reset our error flag!
            m_bInternalError = false;

            if (m_sqlCmd != null)
            {
                try
                {
                    m_sqlCmd.Dispose();
                    m_sqlCmd = null;
                }
                catch (Exception)
                {
                }
            }

            m_sqlCmd = m_sqlConn.CreateCommand();
            m_sqlCmd.CommandText = sSQL;
            m_sqlCmd.CommandTimeout = m_nCmdTimeout;
            m_sqlCmd.CommandType = CommandType.Text;

            return true;
        }

        /// <summary>
        /// Create an SQL command object to run the specified SQL query
        /// </summary>
        /// <param name="sSQL">The query to run</param>
        /// <param name="sqlTrans">The SqlTransaction object to associate with this command</param>
        /// <returns>True if successfull, False otherwise</returns>
        public bool CreateTextCommand(string sSQL, SqlTransaction sqlTrans)
        {
            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            if (m_sqlConn == null)
                return false;

            // reset our error flag!
            m_bInternalError = false;

            if (m_sqlCmd != null)
            {
                try
                {
                    m_sqlCmd.Dispose();
                    m_sqlCmd = null;
                }
                catch (Exception)
                {
                }
            }

            m_sqlCmd = m_sqlConn.CreateCommand();
            m_sqlCmd.CommandText = sSQL;
            m_sqlCmd.CommandTimeout = m_nCmdTimeout;
            m_sqlCmd.CommandType = CommandType.Text;
            m_sqlCmd.Transaction = sqlTrans;

            return true;
        }

        /// <summary>
        /// Gets a Data.DataSet for the SQL command object
        /// </summary>
        /// <returns>The DataSet result, or null if an error and LastError will be set</returns>
        public DataSet GetDataSet()
        {
            DataSet dsResults = null;
            SqlDataAdapter adapter = null;

            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");
            if (m_sqlConn == null || m_sqlCmd == null)
                return null;

            // reset our error flag!
            m_bInternalError = false;

            try
            {
                adapter = new SqlDataAdapter(m_sqlCmd);
                dsResults = new DataSet();
                adapter.Fill(dsResults);
            }
            catch (SqlException sqlEx)
            {
                Debug.WriteLine(sqlEx.ToString());
                m_sLastError = string.Format("Procedure: {0} - {1}", sqlEx.Procedure, sqlEx.Message);
                _LastException = sqlEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            catch (Exception genEx)
            {
                Debug.WriteLine(genEx.Message);
                m_sLastError = genEx.Message;
                _LastException = genEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            finally
            {
                adapter.Dispose();
                adapter = null;
            }

            return dsResults;
        }

        /// <summary>
        /// Gets a Data.DataSet for the SQL query supplied
        /// </summary>
        /// <param name="sSQL">The SQL query to run</param>
        /// <returns>The DataSet result, or null if an error and LastError will be set</returns>
        public DataSet GetDataSet(string sSQL)
        {
            DataSet dsResults = null;
            SqlDataAdapter adapter = null;

            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            if (m_sqlConn == null)
                return null;

            // reset our error flag!
            m_bInternalError = false;

            try
            {
                adapter = new SqlDataAdapter(sSQL, m_sqlConn);
                // this defaults to 30 seconds if we don't override it
                if (adapter.SelectCommand != null)
                    adapter.SelectCommand.CommandTimeout = m_nCmdTimeout;
                dsResults = new DataSet();
                adapter.Fill(dsResults);
            }
            catch (SqlException sqlEx)
            {
                Debug.WriteLine(sqlEx.Message);
                m_sLastError = sqlEx.Message;
                _LastException = sqlEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            catch (Exception genEx)
            {
                Debug.WriteLine(genEx.Message);
                m_sLastError = genEx.Message;
                _LastException = genEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            finally
            {
                adapter.Dispose();
                adapter = null;
            }

            return dsResults;
        }

        /// <summary>
        /// Gets a Data.DataTable from the SQL command object
        /// </summary>
        /// <returns>The DataTable result, or null if an error and LastError will be set</returns>
        public DataTable GetDataTable()
        {
            DataTable dtResults = null;
            SqlDataAdapter adapter = null;

            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");
            if (m_sqlConn == null || m_sqlCmd == null)
                return null;

            // reset our error flag!
            m_bInternalError = false;

            try
            {
                adapter = new SqlDataAdapter(m_sqlCmd);
                dtResults = new DataTable();
                adapter.Fill(dtResults);
            }
            catch (SqlException sqlEx)
            {
                Debug.WriteLine(sqlEx.Message);
                m_sLastError = sqlEx.Message;
                _LastException = sqlEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            catch (Exception genEx)
            {
                Debug.WriteLine(genEx.Message);
                m_sLastError = genEx.Message;
                _LastException = genEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            finally
            {
                adapter.Dispose();
                adapter = null;
            }

            return dtResults;
        }

        /// <summary>
        /// Gets a Data.DataTable from the supplied SQL Statement
        /// </summary>
        /// <param name="sSQL">The SQL statement to run</param>
        /// <returns>The DataTable result, or null if an error and LastError will be set</returns>
        public DataTable GetDataTable(string sSQL)
        {
            DataTable dtResults = null;
            SqlDataAdapter adapter = null;

            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            if (m_sqlConn == null)
                return null;

            // reset our error flag!
            m_bInternalError = false;

            try
            {
                adapter = new SqlDataAdapter(sSQL, m_sqlConn);
                // this defaults to 30 seconds if we don't override it
                if (adapter.SelectCommand != null)
                    adapter.SelectCommand.CommandTimeout = m_nCmdTimeout;
                dtResults = new DataTable();
                adapter.Fill(dtResults);
            }
            catch (SqlException sqlEx)
            {
                Debug.WriteLine(sqlEx.Message);
                m_sLastError = sqlEx.Message;
                _LastException = sqlEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            catch (Exception genEx)
            {
                Debug.WriteLine(genEx.Message);
                m_sLastError = genEx.Message;
                _LastException = genEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            finally
            {
                adapter.Dispose();
                adapter = null;
            }

            return dtResults;
        }

        /// <summary>
        /// Get the schema (structure) of a table
        /// </summary>
        /// <param name="sTableName">The table name in question</param>
        /// <param name="columns">the list of columns, or * for all columns</param>
        /// <returns>Empty DataTable with table schema information</returns>
        public DataTable GetTableSchema(string sTableName, params string[] columns)
        {
            string sSQL = "", sDelim = "";
            DataTable dtSchema = null;
            DataTable dtResults = null;
            SqlDataAdapter adapter = null;

            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            if (m_sqlConn == null)
                return null;

            // reset our error flag!
            m_bInternalError = false;

            try
            {
                sSQL = "SELECT TOP 1 ";
                foreach (string col in columns)
                {
                    sSQL += string.Format("{0}{1}", sDelim, col);
                    sDelim = ", ";
                }
                sSQL += string.Format(" FROM {0}", sTableName);

                adapter = new SqlDataAdapter(sSQL, m_sqlConn);
                if (adapter.SelectCommand != null)
                    adapter.SelectCommand.CommandTimeout = m_nCmdTimeout;
                dtResults = new DataTable();
                adapter.Fill(dtResults);
                dtSchema = dtResults.Clone();
                dtSchema.TableName = sTableName;
            }
            catch (SqlException sqlEx)
            {
                Debug.WriteLine(sqlEx.Message);
                m_sLastError = sqlEx.Message;
                _LastException = sqlEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            catch (Exception genEx)
            {
                Debug.WriteLine(genEx.Message);
                m_sLastError = genEx.Message;
                _LastException = genEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            finally
            {
                adapter.Dispose();
                adapter = null;
            }

            return dtSchema;
        }

        /// <summary>
        /// Executes the query, and returns the first column of the first row in the result set returned by the query. Additional columns or rows are ignored
        /// </summary>
        /// <param name="sSQL">The SQL query to execute</param>
        /// <returns>First column of first row in the result set, or null if an error</returns>
        public object ExecuteScalar(string sSQL)
        {
            SqlCommand cmd = null;
            object oResult = null;

            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            if (m_sqlConn == null)
                return null;

            // reset our error flag!
            m_bInternalError = false;

            try
            {
                cmd = m_sqlConn.CreateCommand();
                cmd.CommandText = sSQL;
                cmd.CommandTimeout = m_nCmdTimeout;
                cmd.CommandType = CommandType.Text;

                oResult = cmd.ExecuteScalar();
            }
            catch (SqlException sqlEx)
            {
                Debug.WriteLine(sqlEx.Message);
                m_sLastError = sqlEx.Message;
                _LastException = sqlEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            catch (Exception genEx)
            {
                Debug.WriteLine(genEx.Message);
                m_sLastError = genEx.Message;
                _LastException = genEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            finally
            {
                cmd.Dispose();
                cmd = null;
            }

            return oResult;
        }

        /// <summary>
        /// Executes the query, and returns the first column of the first row in the result set returned by the query. Additional columns or rows are ignored
        /// </summary>
        /// <returns>First column of first row in the result set, or null if an error</returns>
        public object ExecuteScalar()
        {
            object oResult = null;

            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null. Create the command object first!");
            if (m_sqlConn == null || m_sqlCmd == null)
                return 0;

            // reset our error flag!
            m_bInternalError = false;

            try
            {
                oResult = m_sqlCmd.ExecuteScalar();
            }
            catch (SqlException sqlEx)
            {
                Debug.WriteLine(sqlEx.Message);
                m_sLastError = sqlEx.Message;
                _LastException = sqlEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            catch (Exception genEx)
            {
                Debug.WriteLine(genEx.Message);
                m_sLastError = genEx.Message;
                _LastException = genEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            finally
            {
            }

            return oResult;
        }

        /// <summary>
        /// Executes a Transact-SQL statement against the connection and returns the number of rows affected
        /// </summary>
        /// <returns>The number of rows affected</returns>
        public int ExecuteNonQuery()
        {
            int nRowsAffected = 0;

            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null. Create the command object first!");
            if (m_sqlConn == null || m_sqlCmd == null)
                return 0;

            // reset our error flag!
            m_bInternalError = false;

            try
            {
                nRowsAffected = m_sqlCmd.ExecuteNonQuery();
            }
            catch (SqlException sqlEx)
            {
                Debug.WriteLine(sqlEx.Message);
                m_sLastError = sqlEx.Message;
                _LastException = sqlEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            catch (Exception genEx)
            {
                Debug.WriteLine(genEx.Message);
                m_sLastError = genEx.Message;
                _LastException = genEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }

            return nRowsAffected;
        }

        /// <summary>
        /// Executes a Transact-SQL statement against the connection and returns the number of rows affected
        /// </summary>
        /// <param name="sSQL">The SQL query to execute</param>
        /// <returns>The number of rows affected</returns>
        public int ExecuteNonQuery(string sSQL)
        {
            int nRowsAffected = 0;
            SqlCommand cmd = null;

            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            if (m_sqlConn == null)
                return 0;

            // reset our error flag!
            m_bInternalError = false;

            try
            {
                cmd = m_sqlConn.CreateCommand();
                cmd.CommandText = sSQL;
                cmd.CommandTimeout = m_nCmdTimeout;
                cmd.CommandType = CommandType.Text;

                nRowsAffected = cmd.ExecuteNonQuery();
            }
            catch (SqlException sqlEx)
            {
                Debug.WriteLine(sqlEx.Message);
                m_sLastError = sqlEx.Message;
                _LastException = sqlEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            catch (Exception genEx)
            {
                Debug.WriteLine(genEx.Message);
                m_sLastError = genEx.Message;
                _LastException = genEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            finally
            {
                cmd.Dispose();
                cmd = null;
            }

            return nRowsAffected;
        }

        /// <summary>
        /// Executes the SQLCommand on the Connection and builds a SqlDataReader. 
        /// </summary>
        /// <returns>The SqlDataReader result set</returns>
        public SqlDataReader ExecuteReader()
        {
            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null. Create the command object first!");
            if (m_sqlConn == null || m_sqlCmd == null)
                return null;

            SqlDataReader drResults = null;

            // reset our error flag!
            m_bInternalError = false;

            try
            {
                drResults = m_sqlCmd.ExecuteReader();
            }
            catch (SqlException sqlEx)
            {
                Debug.WriteLine(sqlEx.Message);
                m_sLastError = sqlEx.Message;
                _LastException = sqlEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }
            catch (Exception genEx)
            {
                Debug.WriteLine(genEx.Message);
                m_sLastError = genEx.Message;
                _LastException = genEx;

                // set our error flag!
                m_bInternalError = true;
                throw _LastException;
            }

            return drResults;
        }

        /// <summary>
        /// Executes the SQL on the Connection and builds a SqlDataReader. 
        /// </summary>
        /// <param name="sSQL">The SQL to execute</param>
        /// <returns>The SqlDataReader result set</returns>
        public SqlDataReader ExecuteReader(string sSQL)
        {
            Debug.Assert(m_sqlConn != null, "m_sqlConn is null.");
            if (m_sqlConn == null)
                return null;

            SqlCommand cmd = null;
            SqlDataReader drResults = null;

            // reset our error flag!
            m_bInternalError = false;

            try
            {
                cmd = m_sqlConn.CreateCommand();
                cmd.CommandText = sSQL;
                cmd.CommandTimeout = m_nCmdTimeout;
                cmd.CommandType = CommandType.Text;

                drResults = cmd.ExecuteReader();
            }
            catch (SqlException sqlEx)
            {
                Debug.WriteLine(sqlEx.Message);
                m_sLastError = sqlEx.Message;
                _LastException = sqlEx;

                // set our error flag!
                m_bInternalError = true;
            }
            catch (Exception genEx)
            {
                Debug.WriteLine(genEx.Message);
                m_sLastError = genEx.Message;
                _LastException = genEx;

                // set our error flag!
                m_bInternalError = true;
            }
            finally
            {
                cmd.Dispose();
                cmd = null;
            }

            return drResults;
        }

        #endregion


        #region Public Methods: Parameters

        /// <summary>
        /// Add a string/Varchar2 input parameter to the SQL command object
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        /// <param name="sValue">The value to give the parameter</param>
        public void AddInputParameter(string sParamName, string sValue)
        {
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");

            // make sure we use DBNull if appropriate
            object oDBValue = sValue;
            if (string.IsNullOrEmpty(sValue))
                oDBValue = DBNull.Value;

            if (m_sqlCmd.Parameters.Contains(sParamName))
            {
                UpdateParameterValue(sParamName, oDBValue);
                return;
            }

            // create the parameter
            SqlParameter param = new SqlParameter();

            // set all the properties as appropriate
            param.Value = oDBValue;
            param.ParameterName = sParamName;
            param.SqlDbType = SqlDbType.VarChar;
            param.Direction = ParameterDirection.Input;

            // add the parameter to the command
            m_sqlCmd.Parameters.Add(param);
        }

        /// <summary>
        /// Add an integer input parameter to the SQL command object
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        /// <param name="nValue">The value to give the parameter</param>
        public void AddInputParameter(string sParamName, int nValue)
        {
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");

            if (m_sqlCmd.Parameters.Contains(sParamName))
            {
                UpdateParameterValue(sParamName, nValue);
                return;
            }

            // create the parameter
            SqlParameter param = new SqlParameter();

            // set all the properties as appropriate
            param.Value = nValue;
            param.ParameterName = sParamName;
            param.SqlDbType = SqlDbType.Int;
            param.Direction = ParameterDirection.Input;

            // add the parameter to the command
            m_sqlCmd.Parameters.Add(param);
        }

        /// <summary>
        /// Add an integer input parameter to the SQL command object
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        /// <param name="nValue">The value to give the parameter</param>
        public void AddInputParameter(string sParamName, int? nValue)
        {
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");

            // make sure we use DBNull if appropriate
            object oDBValue;
            {
                if (nValue.HasValue)
                    oDBValue = nValue.Value;
                else
                    oDBValue = DBNull.Value;
            }

            if (m_sqlCmd.Parameters.Contains(sParamName))
            {
                UpdateParameterValue(sParamName, oDBValue);
                return;
            }

            // create the parameter
            SqlParameter param = new SqlParameter();

            // set all the properties as appropriate
            param.Value = oDBValue;
            param.ParameterName = sParamName;
            param.SqlDbType = SqlDbType.Int;
            param.Direction = ParameterDirection.Input;

            // add the parameter to the command
            m_sqlCmd.Parameters.Add(param);
        }

        /// <summary>
        /// Add a decimal/numeric input parameter to the SQL command object
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        /// <param name="nValue">The value to give the parameter</param>
        public void AddInputParameter(string sParamName, decimal nValue)
        {
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");

            if (m_sqlCmd.Parameters.Contains(sParamName))
            {
                UpdateParameterValue(sParamName, nValue);
                return;
            }

            // create the parameter
            SqlParameter param = new SqlParameter();

            // set all the properties as appropriate
            param.Value = nValue;
            param.ParameterName = sParamName;
            param.SqlDbType = SqlDbType.Decimal;
            param.Direction = ParameterDirection.Input;

            // add the parameter to the command
            m_sqlCmd.Parameters.Add(param);
        }

        /// <summary>
        /// Add a datetime input parameter to the SQL command object
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        /// <param name="dtValue">The value to give the parameter</param>
        public void AddInputParameter(string sParamName, DateTime dtValue)
        {
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");
            SqlDateTime dtRealValue = SqlDateTime.MinValue;
            if (dtValue.CompareTo((DateTime)SqlDateTime.MinValue) > 0)
                dtRealValue = dtValue;

            if (m_sqlCmd.Parameters.Contains(sParamName))
            {
                UpdateParameterValue(sParamName, dtRealValue);
                return;
            }

            // create the parameter
            SqlParameter param = new SqlParameter();

            // set all the properties as appropriate
            param.Value = dtRealValue;
            param.ParameterName = sParamName;
            param.SqlDbType = SqlDbType.DateTime;
            param.Direction = ParameterDirection.Input;

            // add the parameter to the command
            m_sqlCmd.Parameters.Add(param);
        }

        /// <summary>
        /// Add an integer input parameter to the SQL command object
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        /// <param name="nValue">The value to give the parameter</param>
        public void AddInputParameter(string sParamName, DateTime? nValue)
        {
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");

            // make sure we use DBNull if appropriate
            object oDBValue;
            {
                if (nValue.HasValue)
                    oDBValue = nValue.Value;
                else
                    oDBValue = DBNull.Value;
            }

            if (m_sqlCmd.Parameters.Contains(sParamName))
            {
                UpdateParameterValue(sParamName, oDBValue);
                return;
            }

            // create the parameter
            SqlParameter param = new SqlParameter();

            // set all the properties as appropriate
            param.Value = oDBValue;
            param.ParameterName = sParamName;
            param.SqlDbType = SqlDbType.DateTime;
            param.Direction = ParameterDirection.Input;

            // add the parameter to the command
            m_sqlCmd.Parameters.Add(param);
        }

        /// <summary>
        /// Add an input parameter to the SQL command object
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        /// <param name="dbType">The SQL database type of the parameter</param>
        /// <param name="oValue">The value to give the parameter</param>
        public void AddInputParameter(string sParamName, SqlDbType dbType, object oValue)
        {
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");

            if (m_sqlCmd.Parameters.Contains(sParamName))
            {
                UpdateParameterValue(sParamName, oValue);
                return;
            }

            SqlParameter param = new SqlParameter();

            // make sure we use DBNull if appropriate
            object oDBValue = oValue;
            if (oValue == null)
                oDBValue = DBNull.Value;

            // set all the properties as appropriate
            param.Value = oDBValue;
            param.SqlDbType = dbType;
            param.ParameterName = sParamName;
            param.Direction = ParameterDirection.Input;

            // add the parameter to the command
            m_sqlCmd.Parameters.Add(param);
        }

        /// <summary>
        /// Add an input parameter to the SQL command object
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        /// <param name="oValue">The value to give the parameter</param>
        /// <param name="dataType">The datatype of the value</param>
        public void AddInputParameter(string sParamName, object oValue, Type dataType)
        {
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");

            if (m_sqlCmd.Parameters.Contains(sParamName))
            {
                UpdateParameterValue(sParamName, oValue);
                return;
            }

            SqlParameter param = new SqlParameter();

            // make sure we use DBNull if appropriate
            object oDBValue = oValue;
            if (oValue == null)
                oDBValue = DBNull.Value;

            // set all the properties as appropriate
            param.Value = oDBValue;
            param.ParameterName = sParamName;
            param.Direction = ParameterDirection.Input;

            if (dataType == System.Type.GetType("System.String"))
                param.SqlDbType = SqlDbType.VarChar;
            else if (dataType == System.Type.GetType("System.DateTime"))
                param.SqlDbType = SqlDbType.DateTime;
            else if (dataType == System.Type.GetType("System.Decimal"))
                param.SqlDbType = SqlDbType.Decimal;
            else if (dataType == System.Type.GetType("System.Int32"))
                param.SqlDbType = SqlDbType.Int;

            // add the parameter to the command
            m_sqlCmd.Parameters.Add(param);
        }

        /// <summary>
        /// Update an parameter's value
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        /// <param name="oValue">The value to give the parameter</param>
        public void UpdateParameterValue(string sParamName, object oValue)
        {
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");

            // make sure we use DBNull if appropriate
            object oDBValue = oValue;
            if (oValue == null)
                oDBValue = DBNull.Value;

            m_sqlCmd.Parameters[sParamName].Value = oDBValue;
        }

        /// <summary>
        /// Add an output parameter to the SQL command object
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        /// <param name="sqlDbType">The SQL database type of the parameter</param>
        public void AddOutputParameter(string sParamName, SqlDbType sqlDbType)
        {
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");

            SqlParameter param = new SqlParameter(sParamName, sqlDbType);
            param.Direction = ParameterDirection.Output;
            m_sqlCmd.Parameters.Add(param);
        }

        /// <summary>
        /// Add a string/Varchar output parameter to the SQL command object
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        /// <param name="nSize">The size/length of the Varchar parameter</param>
        public void AddOutputParameterString(string sParamName, int nSize)
        {
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");

            SqlParameter param = new SqlParameter(sParamName, SqlDbType.VarChar);
            param.Size = nSize;
            param.Direction = ParameterDirection.Output;
            m_sqlCmd.Parameters.Add(param);
        }

        /// <summary>
        /// Add a integer output parameter to the SQL command object
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        public void AddOutputParameterInt(string sParamName)
        {
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");

            SqlParameter param = new SqlParameter(sParamName, SqlDbType.Int);
            param.Direction = ParameterDirection.Output;
            m_sqlCmd.Parameters.Add(param);
        }

        /// <summary>
        /// Add a DateTime output parameter to the SQL command object
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        public void AddOutputParameterDateTime(string sParamName)
        {
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");

            SqlParameter param = new SqlParameter(sParamName, SqlDbType.DateTime);
            param.Direction = ParameterDirection.Output;
            m_sqlCmd.Parameters.Add(param);
        }

        /// <summary>
        /// Add a decimal output parameter to the SQL command object
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        public void AddOutputParameterDecimal(string sParamName)
        {
            Debug.Assert(m_sqlCmd != null, "m_sqlCmd is null.");

            SqlParameter param = new SqlParameter(sParamName, SqlDbType.Decimal);
            param.Direction = ParameterDirection.Output;
            m_sqlCmd.Parameters.Add(param);
        }


        /// <summary>
        /// Get the string value of a named parameter from the executed SQL command
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        /// <returns>The string value of the named parameter</returns>
        public string GetParameterString(string sParamName)
        {
            string sValue = string.Empty;
            if (m_sqlCmd.Parameters[sParamName].Value != DBNull.Value && m_sqlCmd.Parameters[sParamName].Value != null)
                sValue = m_sqlCmd.Parameters[sParamName].Value.ToString();
            return sValue;
        }

        /// <summary>
        /// Get the integer value of a named parameter from the executed SQL command
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        /// <returns>The int value of the named parameter</returns>
        public int? GetParameterInt(string sParamName)
        {
            int? nValue = null;
            if (m_sqlCmd.Parameters[sParamName].Value != DBNull.Value && m_sqlCmd.Parameters[sParamName].Value != null)
                nValue = (int)m_sqlCmd.Parameters[sParamName].Value;
            return nValue;
        }

        /// <summary>
        /// Get the DateTime value of a named parameter from the executed SQL command
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        /// <returns>The DateTime value of the named parameter</returns>
        public DateTime GetParameterDateTime(string sParamName)
        {
            DateTime dtValue = DateTime.MinValue;
            if (m_sqlCmd.Parameters[sParamName].Value != DBNull.Value && m_sqlCmd.Parameters[sParamName].Value != null)
                dtValue = (DateTime)m_sqlCmd.Parameters[sParamName].Value;
            return dtValue;
        }

        /// <summary>
        /// Get the integer value of a named parameter from the executed SQL command
        /// </summary>
        /// <param name="sParamName">The name of the parameter</param>
        /// <returns>The int value of the named parameter</returns>
        public decimal? GetParameterDecimal(string sParamName)
        {
            decimal? nValue = null;
            if (m_sqlCmd.Parameters[sParamName].Value != DBNull.Value && m_sqlCmd.Parameters[sParamName].Value != null)
                nValue = (decimal)m_sqlCmd.Parameters[sParamName].Value;
            return nValue;
        }

        #endregion


        #region Public Methods: Bulk Loading

        /// <summary>
        /// Bulk load wrapper
        /// </summary>
        /// <param name="sourceTable">The source data table.</param>
        /// <param name="targetTableName">The target table name.</param>
        /// <param name="excludeColumnNames">List of column names to exclude from copy.</param>
        /// <param name="sqlTransaction">The transaction to use, null if none.</param>
        /// <param name="errorMessage">Error message.</param>
        /// <returns>True if successful.</returns>
        public bool BulkLoad(DataTable sourceTable,
                             string targetTableName,
                             List<string> excludeColumnNames,
                             SqlTransaction sqlTransaction,
                             ref string errorMessage)
        {
            bool result;

            string errorTemplate = string.Format("BulkLoad[{0}]: {1}", targetTableName, "{0}");

            if ((sourceTable != null) && (sourceTable.Rows.Count > 0))
            {
                SqlBulkCopy bulkCopy = new SqlBulkCopy(m_sqlConn, SqlBulkCopyOptions.Default, sqlTransaction);

                try
                {
                    bulkCopy.BulkCopyTimeout = 600;

                    bulkCopy.DestinationTableName = targetTableName;

                    if ((excludeColumnNames != null) && (excludeColumnNames.Count > 0))
                    {
                        bulkCopy.ColumnMappings.Clear();

                        foreach (DataColumn column in sourceTable.Columns)
                        {
                            if (!excludeColumnNames.Contains(column.ColumnName))
                                bulkCopy.ColumnMappings.Add(new SqlBulkCopyColumnMapping(column.ColumnName, column.ColumnName));
                        }
                    }

                    bulkCopy.WriteToServer(sourceTable);
                    bulkCopy.Close();

                    result = true;
                }
                catch (Exception ex)
                {
                    errorMessage = string.Format(errorTemplate, ex.Message);
                    result = false;
                }
                finally
                {
                    bulkCopy = null;
                }
            }
            else
                result = true;

            return result;
        }

        /// <summary>
        /// Bulk load wrapper
        /// </summary>
        /// <param name="sourceTable">The source data table.</param>
        /// <param name="targetTableName">The target table name.</param>
        /// <param name="excludeColumnNames">List of column names to exclude from copy.</param>
        /// <param name="sqlTransaction">The transaction to use, null if none.</param>
        /// <param name="errorMessage">Error message.</param>
        /// <returns>True if successful.</returns>
        public bool BulkLoad(DataTable sourceTable,
                             string targetTableName,
                             string[] excludeColumnNames,
                             SqlTransaction sqlTransaction,
                             ref string errorMessage)
        {
            bool result;

            List<string> excludeColumnNameCollection = new List<string>(excludeColumnNames.Length);

            for (int columnDex = 0; columnDex < excludeColumnNames.Length; columnDex++)
                excludeColumnNameCollection.Add(excludeColumnNames[columnDex]);

            result = BulkLoad(sourceTable,
                              targetTableName,
                              excludeColumnNameCollection,
                              sqlTransaction,
                              ref errorMessage);

            return result;
        }

        /// <summary>
        /// Bulk load wrapper
        /// </summary>
        /// <param name="sourceTable">The source data table.</param>
        /// <param name="targetTableName">The target table name.</param>
        /// <param name="sqlTransaction">The transaction to use, null if none.</param>
        /// <param name="errorMessage">Error message.</param>
        /// <returns>True if successful.</returns>
        public bool BulkLoad(DataTable sourceTable,
                             string targetTableName,
                             SqlTransaction sqlTransaction,
                             ref string errorMessage)
        {
            bool result;

            result = BulkLoad(sourceTable,
                              targetTableName,
                              (List<string>)null,
                              sqlTransaction,
                              ref errorMessage);

            return result;
        }

        /// <summary>
        /// Bulk load wrapper
        /// </summary>
        /// <param name="sourceTable">The source data table.</param>
        /// <param name="targetTableName">The target table name.</param>
        /// <param name="excludeColumnNames">List of column names to exclude from copy.</param>
        /// <param name="errorMessage">Error message.</param>
        /// <returns>True if successful.</returns>
        public bool BulkLoad(DataTable sourceTable,
                             string targetTableName,
                             List<string> excludeColumnNames,
                             ref string errorMessage)
        {
            bool result;

            result = BulkLoad(sourceTable,
                              targetTableName,
                              excludeColumnNames,
                              null,
                              ref errorMessage);

            return result;
        }

        /// <summary>
        /// Bulk load wrapper
        /// </summary>
        /// <param name="sourceTable">The source data table.</param>
        /// <param name="targetTableName">The target table name.</param>
        /// <param name="excludeColumnNames">List of column names to exclude from copy.</param>
        /// <param name="errorMessage">Error message.</param>
        /// <returns>True if successful.</returns>
        public bool BulkLoad(DataTable sourceTable,
                             string targetTableName,
                             string[] excludeColumnNames,
                             ref string errorMessage)
        {
            bool result;

            result = BulkLoad(sourceTable,
                              targetTableName,
                              excludeColumnNames,
                              null,
                              ref errorMessage);

            return result;
        }

        /// <summary>
        /// Bulk load wrapper
        /// </summary>
        /// <param name="sourceTable">The source data table.</param>
        /// <param name="targetTableName">The target table name.</param>
        /// <param name="errorMessage">Error message.</param>
        /// <returns>True if successful.</returns>
        public bool BulkLoad(DataTable sourceTable,
                             string targetTableName,
                             ref string errorMessage)
        {
            bool result;

            result = BulkLoad(sourceTable,
                              targetTableName,
                              (List<string>)null,
                              null,
                              ref errorMessage);

            return result;
        }

        #endregion


        #region Public Methods: ECMPS Workspace

        #region Public Methods: Workspace Clear

        /// <summary>
        /// Clear the scratch tables for the given type
        /// </summary>
        /// <param name="eType">QA, EM or LME</param>
        /// <param name="nSessionId">The id of the session to clear</param>
        /// <param name="sqlTransaction">The current SQL transaction.</param>
        /// <returns>true if successful, false if error and LastError contains error message</returns>
        public bool ClearScratchSession(eWorkspaceDataType eType, decimal nSessionId,
                                        ref SqlTransaction sqlTransaction)
        {
            bool bSuccessful = false;

            if (sqlTransaction == null)
                this.CreateStoredProcedureCommand("CLEAR_SCRATCH_TABLES2");
            else
                this.CreateStoredProcedureCommand("CLEAR_SCRATCH_TABLES2", sqlTransaction);

            this.AddInputParameter("@V_TYPE", eType.ToCode());
            this.AddInputParameter("@V_SESSION_ID", nSessionId);
            this.AddOutputParameterString("@V_RESULT", 1);
            this.AddOutputParameterString("@V_ERROR_MSG", 200);

            this.ExecuteNonQuery();
            if (this.GetParameterString("@V_RESULT") != "T")
                m_sLastError = this.GetParameterString("@V_ERROR_MSG");
            else
                bSuccessful = true;

            return bSuccessful;
        }

        /// <summary>
        /// Clear the scratch tables for the given type
        /// </summary>
        /// <param name="eType">QA, EM or LME</param>
        /// <param name="nSessionId">The id of the session to clear</param>
        /// <returns>true if successful, false if error and LastError contains error message</returns>
        public bool ClearScratchSession(eWorkspaceDataType eType, decimal nSessionId)
        {
            SqlTransaction Transaction = null;

            return ClearScratchSession(eType, nSessionId, ref Transaction);
        }

        /// <summary>
        /// Clear the calc updates tables for the given type
        /// </summary>
        /// <param name="eType">QA, EM or LME</param>
        /// <param name="nSessionId">The id of the session to clear</param>
        /// <param name="sqlTransaction">The current SQL transaction.</param>
        /// <returns>true if successful, false if error and LastError contains error message</returns>
        public bool ClearUpdateSession(eWorkspaceDataType eType, decimal nSessionId,
                                       ref SqlTransaction sqlTransaction)
        {
            bool bSuccessful = false;

            if (sqlTransaction == null)
                this.CreateStoredProcedureCommand("CLEAR_UPDATE_SESSION");
            else
                this.CreateStoredProcedureCommand("CLEAR_UPDATE_SESSION", sqlTransaction);

            this.AddInputParameter("@V_TYPE", eType.ToCode());
            this.AddInputParameter("@V_SESSION_ID", nSessionId);
            this.AddOutputParameterString("@V_RESULT", 1);
            this.AddOutputParameterString("@V_ERROR_MSG", 200);

            this.ExecuteNonQuery();
            if (this.GetParameterString("@V_RESULT") != "T")
                m_sLastError = this.GetParameterString("@V_ERROR_MSG");
            else
                bSuccessful = true;

            return bSuccessful;
        }

        /// <summary>
        /// Clear the calc updates tables for the given type
        /// </summary>
        /// <param name="eType">QA, EM or LME</param>
        /// <param name="nSessionId">The id of the session to clear</param>
        /// <returns>true if successful, false if error and LastError contains error message</returns>
        public bool ClearUpdateSession(eWorkspaceDataType eType, decimal nSessionId)
        {
            SqlTransaction Transaction = null;

            return ClearUpdateSession(eType, nSessionId, ref Transaction);
        }

        ///// <summary>
        ///// Clear the scratch tables for the given type
        ///// </summary>
        ///// <param name="eType">QA, EM or LME</param>
        ///// <returns>true if successful, false if error and LastError contains error message</returns>
        //public bool ClearScratchTables(eWorkspaceDataType eType)
        //{
        //  bool bSuccessful = false;

        //  this.CreateStoredProcedureCommand("CLEAR_SCRATCH_TABLES");
        //  this.AddInputParameter("@V_TYPE", eType.ToCode());
        //  this.AddOutputParameterString("@V_RESULT", 1);
        //  this.AddOutputParameterString("@V_ERROR_MSG", 200);

        //  this.ExecuteNonQuery();
        //  if (this.GetParameterString("@V_RESULT") != "T")
        //    m_sLastError = this.GetParameterString("@V_ERROR_MSG");
        //  else
        //    bSuccessful = true;

        //  return bSuccessful;
        //}

        ///// <summary>
        ///// Clear the calc updates tables for the given type
        ///// </summary>
        ///// <param name="eType">QA, EM or LME</param>
        ///// <returns>true if successful, false if error and LastError contains error message</returns>
        //public bool ClearUpdateTables(eWorkspaceDataType eType)
        //{
        //  bool bSuccessful = false;

        //  this.CreateStoredProcedureCommand("CLEAR_UPDATE_TABLES");
        //  this.AddInputParameter("@V_TYPE", eType.ToCode());
        //  this.AddOutputParameterString("@V_RESULT", 1);
        //  this.AddOutputParameterString("@V_ERROR_MSG", 200);

        //  this.ExecuteNonQuery();
        //  if (this.GetParameterString("@V_RESULT") != "T")
        //    m_sLastError = this.GetParameterString("@V_ERROR_MSG");
        //  else
        //    bSuccessful = true;

        //  return bSuccessful;
        //}

        #endregion


        #region Public Methods: Workspace Migrate

        /// <summary>
        /// Migrates calculated data from the ECMPS_WS database to the ECMPS database.
        /// </summary>
        /// <param name="workspaceDataType">The type of data to migrate.</param>
        /// <param name="workspaceSessionId">The session id of the data to migrate.</param>
        /// <param name="monPlanId">The monitor plan of the data to migrate.</param>
        /// <param name="rptPeriodId">The reporting period of the data to migrate.</param>
        /// <param name="userId">The user id to associate with the migration.</param>
        /// <param name="sqlTransaction">The current SQL transaction.</param>
        /// <returns>True if the migration succeded.</returns>
        public bool MigrateWorkspaceSession(eWorkspaceDataType? workspaceDataType,
                                            decimal workspaceSessionId,
                                            string monPlanId,
                                            int? rptPeriodId,
                                            string userId,
                                            ref SqlTransaction sqlTransaction)
        {
            bool result;

            switch (workspaceDataType)
            {
                case eWorkspaceDataType.EM:
                    {
                        result = MigrateWorkspaceSession_EM(workspaceSessionId, monPlanId, rptPeriodId.Value, userId, ref sqlTransaction);
                    }
                    break;

                case eWorkspaceDataType.LME:
                    {
                        result = MigrateWorkspaceSession_LME(workspaceSessionId, monPlanId, rptPeriodId.Value, userId, ref sqlTransaction);
                    }
                    break;

                case eWorkspaceDataType.QA:
                    {
                        result = MigrateWorkspaceSession_QA(workspaceSessionId, userId, ref sqlTransaction);
                    }
                    break;

                case eWorkspaceDataType.EMGEN:
                    {
                        result = MigrateWorkspaceSession_EMGEN(workspaceSessionId, monPlanId, rptPeriodId.Value, ref sqlTransaction);
                    }
                    break;

                default:
                    {
                        result = true;
                    }
                    break;
            }

            return result;
        }

        /// <summary>
        /// Migrates emissions evaluation calculated data from the workspace
        /// schema to the data schema.
        /// </summary>
        /// <param name="nSessionId">The session id of the data to migrate.</param>
        /// <param name="sMonPlanId">The monitor plan of the data to migrate.</param>
        /// <param name="iRptPeriodId">The reporting period of the data to migrate.</param>
        /// <param name="sUserId">The user id to associate with the migration.</param>
        /// <param name="sqlTransaction">The current SQL transaction.</param>
        /// <returns>True if the migration succeded.</returns>
        public bool MigrateWorkspaceSession_EM(decimal nSessionId,
                                               string sMonPlanId, int iRptPeriodId,
                                               string sUserId,
                                               ref SqlTransaction sqlTransaction)
        {
            bool Result;

            this.CreateStoredProcedureCommand("UPD_SESSION_CALCULATED_EM", sqlTransaction);
            this.AddInputParameter("@V_SESSION_ID", nSessionId);
            this.AddInputParameter("@V_MON_PLAN_ID", sMonPlanId);
            this.AddInputParameter("@V_RPT_PERIOD_ID", iRptPeriodId);
            this.AddInputParameter("@V_CURRENT_USERID", sUserId);
            this.AddOutputParameterString("@V_RESULT", 1);
            this.AddOutputParameterString("@V_ERROR_MSG", 200);

            try
            {
                this.ExecuteNonQuery();

                if (this.GetParameterString("@V_RESULT") == "T")
                    Result = true;
                else
                {
                    m_sLastError = this.GetParameterString("@V_ERROR_MSG");
                    Result = false;
                }
            }
            catch (Exception ex)
            {
                if ((this.GetParameterString("@V_RESULT") == "F") &&
                     this.GetParameterString("@V_ERROR_MSG").HasValue())
                {
                    m_sLastError = this.GetParameterString("@V_ERROR_MSG");
                    Result = false;
                }
                else
                {
                    m_sLastError = ex.Message;
                    Result = false;

                    throw _LastException;
                }
            }

            return Result;
        }

        /// <summary>
        /// Migrates data generated for LME from the workspace
        /// schema to the data schema.
        /// </summary>
        /// <param name="sessionId">The session id of the data to migrate.</param>
        /// <param name="monPlanId">The monitor plan of the data to migrate.</param>
        /// <param name="rptPeriodId">The reporting period of the data to migrate.</param>
        /// <param name="sqlTransaction">The current SQL transaction.</param>
        /// <returns>True if the migration succeded.</returns>
        public bool MigrateWorkspaceSession_EMGEN(decimal sessionId,
                                                  string monPlanId,
                                                  int rptPeriodId,
                                                  ref SqlTransaction sqlTransaction)
        {
            bool Result;

            this.CreateStoredProcedureCommand("CheckEmGen.MigrateWorkspace", sqlTransaction);
            this.AddInputParameter("@sessionId", sessionId);
            this.AddInputParameter("@monPlanId", monPlanId);
            this.AddInputParameter("@rptPeriodId", rptPeriodId);
            this.AddOutputParameterString("@result", 1);
            this.AddOutputParameterString("@resultMessage", 200);

            try
            {
                this.ExecuteNonQuery();

                if (this.GetParameterString("@result") == "T")
                    Result = true;
                else
                {
                    m_sLastError = this.GetParameterString("@resultMessage");
                    Result = false;
                }
            }
            catch (Exception ex)
            {
                if ((this.GetParameterString("@result") == "F") &&
                     this.GetParameterString("@resultMessage").HasValue())
                {
                    m_sLastError = this.GetParameterString("@resultMessage");
                    Result = false;
                }
                else
                {
                    m_sLastError = ex.Message;
                    Result = false;

                    throw _LastException;
                }
            }

            return Result;
        }

        /// <summary>
        /// Migrates data generated for LME from the workspace
        /// schema to the data schema.
        /// </summary>
        /// <param name="nSessionId">The session id of the data to migrate.</param>
        /// <param name="sMonPlanId">The monitor plan of the data to migrate.</param>
        /// <param name="iRptPeriodId">The reporting period of the data to migrate.</param>
        /// <param name="sUserId">The user id to associate with the migration.</param>
        /// <param name="sqlTransaction">The current SQL transaction.</param>
        /// <returns>True if the migration succeded.</returns>
        public bool MigrateWorkspaceSession_LME(decimal nSessionId,
                                                string sMonPlanId, int iRptPeriodId,
                                                string sUserId,
                                                ref SqlTransaction sqlTransaction)
        {
            bool Result;

            this.CreateStoredProcedureCommand("UPD_SESSION_GENERATED_LME", sqlTransaction);
            this.AddInputParameter("@V_SESSION_ID", nSessionId);
            this.AddInputParameter("@V_MON_PLAN_ID", sMonPlanId);
            this.AddInputParameter("@V_RPT_PERIOD_ID", iRptPeriodId);
            this.AddInputParameter("@V_CURRENT_USERID", sUserId);
            this.AddOutputParameterString("@V_RESULT", 1);
            this.AddOutputParameterString("@V_ERROR_MSG", 200);

            try
            {
                this.ExecuteNonQuery();

                if (this.GetParameterString("@V_RESULT") == "T")
                    Result = true;
                else
                {
                    m_sLastError = this.GetParameterString("@V_ERROR_MSG");
                    Result = false;
                }
            }
            catch (Exception ex)
            {
                if ((this.GetParameterString("@V_RESULT") == "F") &&
                     this.GetParameterString("@V_ERROR_MSG").HasValue())
                {
                    m_sLastError = this.GetParameterString("@V_ERROR_MSG");
                    Result = false;
                }
                else
                {
                    m_sLastError = ex.Message;
                    Result = false;

                    throw _LastException;
                }
            }

            return Result;
        }

        /// <summary>
        /// Migrates QA/Test evaluation calculated data from the workspace
        /// schema to the data schema.
        /// </summary>
        /// <param name="nSessionId">The session id of the data to migrate.</param>
        /// <param name="sUserId">The user id to associate with the migration.</param>
        /// <param name="sqlTransaction">The current SQL transaction.</param>
        /// <returns>True if the migration succeded.</returns>
        public bool MigrateWorkspaceSession_QA(decimal nSessionId, string sUserId,
                                               ref SqlTransaction sqlTransaction)
        {
            bool Result;

            this.CreateStoredProcedureCommand("UPD_SESSION_CALCULATED_QA", sqlTransaction);
            this.AddInputParameter("@V_SESSION_ID", nSessionId);
            this.AddInputParameter("@V_CURRENT_USERID", sUserId);
            this.AddOutputParameterString("@V_RESULT", 1);
            this.AddOutputParameterString("@V_ERROR_MSG", 200);

            try
            {
                this.ExecuteNonQuery();

                if (this.GetParameterString("@V_RESULT") == "T")
                    Result = true;
                else
                {
                    m_sLastError = this.GetParameterString("@V_ERROR_MSG");
                    Result = false;
                }
            }
            catch (Exception ex)
            {
                if ((this.GetParameterString("@V_RESULT") == "F") &&
                     this.GetParameterString("@V_ERROR_MSG").HasValue())
                {
                    m_sLastError = this.GetParameterString("@V_ERROR_MSG");
                    Result = false;
                }
                else
                {
                    m_sLastError = ex.Message;
                    Result = false;

                    throw _LastException;
                }
            }

            return Result;
        }

        #endregion


        #region Public Methods: Workspace Miscellaneous

        /// <summary>
        /// Get the next session id to use for an evaluation
        /// </summary>
        /// <returns>the next session id, or null if error</returns>
        public decimal? GetNextSessionID()
        {
            decimal? nSessionID = null;
            char? cResult = 'F';
            string sError = null;

            AuxDBDataContext db = this.GetAuxDBContext();
            try
            {
                db.sp_GetNextSessionID(ref nSessionID, ref cResult, ref sError);
            }
            catch (Exception ex)
            {
                this._LastException = ex;
                this.m_bInternalError = true;
            }

            return nSessionID;
        }

        #endregion


        #region Public Static Methods: Severity Code

        private static DataView m_dvSeverityCode = null;

        /// <summary>
        /// Returns the Severity Description associated with the passed Severity Code.
        /// </summary>
        /// <param name="ASeverityCd">The severity code for which a discription is returned.</param>
        /// <param name="ADefault">The default description to use if the passed severity code is not known.</param>
        /// <returns>The description associated with the passed severity code.</returns>
        [Obsolete("Please use new extension method on eSeverityCd", false)]
        public static string GetSeverityDescription(string ASeverityCd, string ADefault)
        {
            string Result = ADefault;

            if ((m_dvSeverityCode != null) || LoadSeverityCode())
            {
                DataRowView SeverityRow = GetSeverityRow(ASeverityCd);

                if ((SeverityRow != null) && (SeverityRow["Severity_Cd_Description"] != DBNull.Value))
                    Result = Convert.ToString(SeverityRow["Severity_Cd_Description"]);
            }

            return Result;
        }

        /// <summary>
        /// Returns the Severity Description associated with the passed Severity Level.
        /// </summary>
        /// <param name="ASeverityCd">The severity code for which a level is returned.</param>
        /// <param name="ADefault">The default level to use if the passed severity code is not known.</param>
        /// <returns>The level associated with the passed severity code.</returns>
        [Obsolete("Please use new extension method on eSeverityCd", false)]
        public static int GetSeverityLevel(string ASeverityCd, int ADefault)
        {
            int Result = ADefault;

            if ((m_dvSeverityCode != null) || LoadSeverityCode())
            {
                DataRowView SeverityRow = GetSeverityRow(ASeverityCd);

                if ((SeverityRow != null) && (SeverityRow["Severity_Level"] != DBNull.Value))
                    Result = Convert.ToInt32(SeverityRow["Severity_Level"]);
            }

            return Result;
        }

        private static DataRowView GetSeverityRow(string ASeverityCd)
        {
            DataRowView Result = null;

            if (!string.IsNullOrEmpty(ASeverityCd))
            {
                m_dvSeverityCode.RowFilter = string.Format("Severity_Cd = '{0}'", ASeverityCd);

                if (m_dvSeverityCode.Count == 1)
                    Result = m_dvSeverityCode[0];

                m_dvSeverityCode.RowFilter = null;
            }

            return Result;
        }

        private static bool LoadSeverityCode()
        {
            string Sql = "select Severity_Cd, Severity_Cd_Description, Severity_Level from Severity_Code";
            cDatabase AuxConn = cDatabase.GetConnection(eCatalog.AUX, "LoadSeverityCode");

            try
            {
                DataTable SverityCodeTable = AuxConn.GetDataTable(Sql);
                m_dvSeverityCode = new DataView(SverityCodeTable, null, "Severity_Cd", DataViewRowState.CurrentRows);
                return true;
            }
            catch (Exception ex)
            {
                m_dvSeverityCode = null;
                System.Diagnostics.Debug.WriteLine(ex.ToString());
                Logging.LogException(new Exception("Loading of SEVERITY_CODE view failed", ex), null);
                return false;
            }
        }

        #endregion

        #endregion


        #region Public Methods: ECMPS DB

        /// <summary>
        /// Get facility information based on the id passed.
        /// </summary>
        /// <param name="lookupType">The type of the passed lookup id</param>
        /// <param name="lookupId">The id used to lookup the facility</param>
        /// <param name="facId">The FAC_ID of the located facility</param>
        /// <param name="firstEcmpsRptPeriodId">The FIRST_ECMPS_RPT_PERIOD_ID of the located facility</param>
        /// <param name="errorMessage">Message indicating why a facility was not found</param>
        /// <returns>True if the facility was located</returns>
        public bool GetFacilityInfo(eFacilityLookupType lookupType,
                                    string lookupId,
                                    ref int? facId,
                                    ref int? firstEcmpsRptPeriodId,
                                    ref string errorMessage)
        {
            bool result;

            DataDBDataContext db = this.GetDataDBContext();

            string lookupTypeCd;
            {
                switch (lookupType)
                {
                    case eFacilityLookupType.MP: lookupTypeCd = "MP"; break;
                    case eFacilityLookupType.ML: lookupTypeCd = "ML"; break;
                    case eFacilityLookupType.TEST: lookupTypeCd = "TEST"; break;
                    case eFacilityLookupType.QCE: lookupTypeCd = "QCE"; break;
                    case eFacilityLookupType.TEE: lookupTypeCd = "TEE"; break;
                    case eFacilityLookupType.FAC: lookupTypeCd = "FAC"; break;
                    default: lookupTypeCd = "ORIS"; break;
                }
            }

            try
            {
                db.GetFacilityInfo(lookupTypeCd, lookupId, ref facId, ref firstEcmpsRptPeriodId, ref errorMessage);
                result = facId.HasValue;
            }
            catch (Exception ex)
            {
                this._LastException = ex;
                this.m_bInternalError = true;

                errorMessage = ex.Message;
                result = false;

            }

            return result;
        }

        /// <summary>
        /// Get facility information based on the id passed.
        /// </summary>
        /// <param name="lookupType">The type of the passed lookup id</param>
        /// <param name="lookupId">The id used to lookup the facility</param>
        /// <param name="facId">The FAC_ID of the located facility</param>
        /// <param name="firstEcmpsRptPeriodId">The FIRST_ECMPS_RPT_PERIOD_ID of the located facility</param>
        /// <returns>True if the facility was located</returns>
        public bool GetFacilityInfo(eFacilityLookupType lookupType,
                                    string lookupId,
                                    ref int? facId,
                                    ref int? firstEcmpsRptPeriodId)
        {
            bool result;

            string errorMessage = null;

            result = GetFacilityInfo(lookupType,
                                     lookupId,
                                     ref facId,
                                     ref firstEcmpsRptPeriodId,
                                     ref errorMessage);

            return result;
        }

        #endregion

    }

    /// <summary>
    /// The types of ids used to lookup facility information
    /// </summary>
    public enum eFacilityLookupType
    {
        /// <summary>
        /// MON_PLAN_ID
        /// </summary>
        MP,

        /// <summary>
        /// MON_LOC_ID
        /// </summary>
        ML,

        /// <summary>
        /// TEST_SUM_ID
        /// </summary>
        TEST,

        /// <summary>
        /// QA_CERT_EVENT_ID
        /// </summary>
        QCE,

        /// <summary>
        /// TEST_EXTENSION_EXEMPTION_ID
        /// </summary>
        TEE,

        /// <summary>
        /// ORIS_CODE
        /// </summary>
        ORIS,

        /// <summary>
        /// FAC_ID
        /// </summary>
        FAC
    }

    /// <summary>
    /// The types of workspace data update by evaluations
    /// </summary>
    public enum eWorkspaceDataType
    {
        /// <summary>
        /// QA/Test Data
        /// </summary>
        QA,

        /// <summary>
        /// Emissions Data
        /// </summary>
        EM,

        /// <summary>
        /// LME Data
        /// </summary>
        LME,

        /// <summary>
        /// Non Operating Emission Generation Data
        /// </summary>
        EMGEN
    }


    /// <summary>
    /// Extensions for Database and DataTable type stuff
    /// </summary>
    public static class DatabaseRelatedExtensions
    {

        /// <summary>
        /// Get a context for the ECMPS_AUX database
        /// </summary>
        /// <param name="oDBConn">The cDatabase connection to use</param>
        /// <returns>New context for the ECMPS_AUX database</returns>
        public static AuxDBDataContext GetAuxDBContext(this cDatabase oDBConn)
        {
            AuxDBDataContext db = new AuxDBDataContext(oDBConn);
            db.CommandTimeout = cDatabase.DefaultCommandTimeout;
            return db;
        }

        /// <summary>
        /// Get a context for the ECMPS database
        /// </summary>
        /// <param name="oDBConn">The cDatabase connection to use</param>
        /// <returns>New context for the ECMPS database</returns>
        public static DataDBDataContext GetDataDBContext(this cDatabase oDBConn)
        {
            DataDBDataContext db = new DataDBDataContext(oDBConn);
            db.CommandTimeout = cDatabase.DefaultCommandTimeout;
            return db;
        }

        /// <summary>
        /// Returns the code associated with the Workspace Data Type enumeration member.
        /// </summary>
        /// <param name="eType">The Workspace Data Type enumeration member.</param>
        /// <returns>The associated code.</returns>
        public static string ToCode(this eWorkspaceDataType eType)
        {
            return eType.ToString().ToUpper();
        }

    }
}
